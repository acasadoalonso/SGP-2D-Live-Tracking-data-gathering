#!/bin/python3
import json
import os
import io
from datetime import datetime
from geopy.distance import geodesic       # use the Vincenty algorithm^M
import config
from parserfuncs import deg2dmslat, deg2dmslon

import psutil
MUT=False
if config.ADSBOpenSky:
    OPENSKY=True
else:
    OPENSKY=False

#-------------------------------------------------------------------------------------------------------------------#


def is_raspberrypi():
    if os.name != 'posix':
        return False
    chips = ('BCM2708', 'BCM2709', 'BCM2711', 'BCM2835', 'BCM2836')
    try:
        with io.open('/proc/cpuinfo', 'r') as cpuinfo:
            for line in cpuinfo:
                if line.startswith('Hardware'):
                    _, value = line.strip().split(':', 1)
                    value = value.strip()
                    if value in chips:
                        return True
    except Exception:
        pass
    return False
#-------------------------------------------------------------------------------------------------------------------#


global _adsbregcache_
_adsbregcache_ = {}
_adsbreg_ = {}


def getadsbreg(icao):			    # get the registration and model from the ICAO ID
    global _adsbregcache_
    global _adsbreg_
    if not config.ADSBreg:		    # check if we want to import the huge file ADSBreg
        return(False)
    if len(_adsbreg_) == 0:	    	    # only import the table if need it
        import ADSBreg			    # this file is huge
        _adsbreg_ = ADSBreg.ADSBreg	    # update the global pointer
    if icao in _adsbregcache_:		    # if ID on the table ???
        return (_adsbregcache_[icao])       # return model and registration
    else:				    # if not found, look into the whole registration DB
        if icao in _adsbreg_:
            _adsbregcache_[icao]=_adsbreg_[icao]  # and update the cache for next time
            return (_adsbregcache_[icao])     # return model and registration
    return False			    # return FALSE


def getsizeadsbcache():			    # just return the size of the cache
    return (len(_adsbregcache_))


def adsbgetapidata(adsbfile): 	            # get the data from the API server
    r=open(adsbfile)			    # open the file generated by dump1090

    js=r.read()
    j_obj = json.loads(js)                  # convert to JSON
    r.close()				    # close the file now
    return j_obj                            # return the JSON object

#-------------------------------------------------------------------------------------------------------------------#
# extract the data of the last know position from the JSON object
#-------------------------------------------------------------------------------------------------------------------#

def adsbaddpos(tracks, adsbpos, ttime, adsbnow, prt=False):

    foundone = False
    for msg in tracks:
        if "flight" in msg:
            flg = msg['flight']
        else:
            continue
        aid = "ICA"+msg['hex'].upper()	    	# aircraft ID
        ttt=adsbnow-msg['seen']		    	# when the aircraft was seen
        					# number of second until beginning of the day
        ts = int(ttt)       		    	# Unix time - seconds from the epoch
        t=datetime.utcfromtimestamp(ts)
        #print ("TTT:", t, ts, (adsbnow-ts) , adsbnow, msg)
        if "lon" in msg:
            lon = msg['lon']
        else:
            continue
        if "lat" in msg:
            lat = msg['lat']			# extract the longitude and latitude
        else:
            continue
        gps = "NO"
        extpos = "NO"
        roc=0
        rot=0
        dir=0
        spd=0
        if MUT:
            if "vert_rate" in msg:
                roc = msg['vert_rate']
            if "speed" in msg:
                spd = msg['speed']
            if "altitude" in msg:
                alt = msg["altitude"] 		# and the altitude
            else:
                continue
        else:
            if "baro_rate" in msg:		# rate of climb in fpm
                roc = msg['baro_rate']
            if "track_rate" in msg:
                rot = msg['track_rate']		# rate of turn in degrees per second
            if "gs" in msg:
                spd = msg['gs']			# ground speed in knots
            if "alt_baro" in msg:
                alt = msg["alt_baro"] 		# and the altitude in feet
            else:
                continue

        if "track" in msg:
            dir = msg['track']
        date = t.strftime("%y%m%d")
        tme = t.strftime("%H%M%S")
        foundone = True

        vitlat = config.FLOGGER_LATITUDE
        vitlon = config.FLOGGER_LONGITUDE
        distance = geodesic((lat, lon), (vitlat, vitlon)).km            # distance to the station
        pos = {"ICAOID": aid, "date": date, "time": tme, "Lat": lat, "Long": lon, "altitude": alt, "UnitID": aid,
               "dist": distance, "course": dir, "speed": spd, "roc": roc, "rot": rot, "GPS": gps, "extpos": extpos, "flight": flg}
        #print "SSS:", ts, ttime, pos
        if ts < ttime+3:		    	# check if the data is from before
            continue		            	# in that case nothing to do
        if alt < int(config.ADSBfl):		# filter by FL

           adsbpos['adsbpos'].append(pos)       # and store it on the dict
        if prt:
            print("adsbPOS :", round(lat, 4), round(lon, 4), alt, aid, round(distance, 4), ts, date, tme, flg)

    return(foundone) 			    	# indicate that we added an entry to the dict


#-------------------------------------------------------------------------------------------------------------------#
    # extract the data of the last know position from the JSON object
def adsbopensky(adsbpos, ttime, prt=True):

    foundone = False
    from opensky_api import OpenSkyApi
    if len(config.ADSBOpenSkyName) > 0:
       api = OpenSkyApi(username=config.ADSBOpenSkyName, password=config.ADSBOpenSkyPswd)		    # open the API
    else:
       api = OpenSkyApi()		    # open the API

    BBox= (float(config.ADSBOpenSkyBox1),   # build the BOX
           float(config.ADSBOpenSkyBox2),
           float(config.ADSBOpenSkyBox3),
           float(config.ADSBOpenSkyBox4))

    # bbox = (min latitude, max latitude, min longitude, max longitude)
    states = api.get_states(bbox=BBox)	    # get the sky vectors
    #
    if states == None:
       return(False)
    for s in states.states:		    # scan all the VECTORS

        if prt:
            print("ICAO=%r, CS=%r, COUNTRY=%r, LON=%r, LAT=%r, BARO=%r, GEOALT=%r, VEL=%ri, HEADING=%r, VERT=%r, SQUAWK=%r, SOURCE=%r, TIME=%r" %
                  (s.icao24, s.callsign, s.origin_country, s.longitude, s.latitude, s.baro_altitude,
                   s.geo_altitude, s.velocity, s.heading, s.vertical_rate,
                   s.squawk, s.position_source, s.time_position))

        aid = "ICA"+s.icao24.upper()	    # aircraft ID
        gps = "NO"			    # NO GPS info
        extpos = "NO"			    # no external position
        rot = 0				    # no rate of turn
        if s.time_position == None:
            continue			    # if no time nothing to do
        ts = int(s.time_position) 	    # Unix time - seconds from the epocha
        t=datetime.utcfromtimestamp(ts)
        date = t.strftime("%y%m%d")
        tme = t.strftime("%H%M%S")
        foundone = True
        lat = s.latitude		    # data from Open Sky Network
        lon = s.longitude
        alt = s.baro_altitude
        if alt == None or alt == 0:
            alt = s.geo_altitude
        if alt == None or alt == 0:
            continue

        flg = s.callsign
        vitlat = config.FLOGGER_LATITUDE
        vitlon = config.FLOGGER_LONGITUDE

        distance = geodesic((lat, lon), (vitlat, vitlon)).km  # distance to the station

        pos = {"ICAOID": aid, "date": date, "time": tme, "Lat": lat, "Long": lon, "altitude": alt, "UnitID": aid,
               "dist": distance, "course": s.heading, "speed": s.velocity, "roc": s.vertical_rate, "rot": rot,
               "GPS": gps, "extpos": extpos, "flight": s.callsign, "squawk": s.squawk}

        if prt:
            print("adsbPOS :", round(lat, 4), round(lon, 4), alt, aid, round(distance, 4), ts, date, tme, flg)

        if ts == None or ts < int(ttime)+3:  # check if the data is from before
            continue		            # in that case nothing to do

        adsbpos['adsbpos'].append(pos)      # and store it on the dict

    return(foundone) 			    # indicate that we added an entry to the dict


#-------------------------------------------------------------------------------------------------------------------#

def adsbstoreitindb(datafix, curs, conn):   # store the fix into the database

    import MySQLdb                          # the SQL data base routines^M
    for fix in datafix['adsbpos']:	    # for each fix on the dict
        id = fix['ICAOID']		    # extract the information
        dte = fix['date']
        hora = fix['time']
        station = config.location_name
        latitude = fix['Lat']
        longitude = fix['Long']
        altitude = fix['altitude']
        speed = fix['speed']
        course = fix['course']
        roclimb = fix['roc']
        rot = fix['rot']
        sensitivity = 0
        gps = fix['GPS']
        uniqueid = str(fix["UnitID"])
        dist = fix['dist']
        extpos = fix['extpos']
        addcmd = "insert into OGNDATA values ('" + id + "','" + dte + "','" + hora + "','" + station + "'," + str(latitude) + "," + str(longitude) + "," + str(altitude) + "," + str(speed) + "," + \
            str(course) + "," + str(roclimb) + "," + str(rot) + "," + str(sensitivity) + \
            ",'" + gps + "','" + uniqueid + "'," + \
            str(dist) + ",'" + extpos + "', 'adsb' ) "
        try:				    # store it on the DDBB
            #print addcmd
            curs.execute(addcmd)
        except MySQLdb.Error as e:
            try:
                print(">>>MySQL Error [%d]: %s" % (e.args[0], e.args[1]))
            except IndexError:
                print(">>>MySQL Error: %s" % str(e))
                print(">>>MySQL error:", addcmd)
            return (False)                  # indicate that we have errors
    conn.commit()                           # commit the DB updates
    return(True)			    # indicate that we have success

#-------------------------------------------------------------------------------------------------------------------#


def adsbaprspush(datafix, conn, prt=False):

    for fix in datafix['adsbpos']:	    # for each fix on the dict
        id = fix['ICAOID']		    # extract the information
        dte = fix['date']
        hora = fix['time']
        station = config.location_name
        latitude = fix['Lat']
        longitude = fix['Long']
        altitude = fix['altitude']
        speed = fix['speed']
        course = fix['course']
        roclimb = fix['roc']
        rot = fix['rot']
        sensitivity = 0
        gps = fix['GPS']
        uniqueid = fix["UnitID"]
        uniqueid = '25'+uniqueid[3:]
        dist = fix['dist']
        extpos = fix['extpos']
        flight = fix['flight']
        # build the APRS message
        lat = deg2dmslat(abs(latitude))
        if latitude > 0:
            lat += 'N'
        else:
            lat += 'S'
        lon = deg2dmslon(abs(longitude))
        if longitude > 0:
            lon += 'E'
        else:
            lon += 'W'

        ccc = "%03d" % int(course)
        sss = "%03d" % int(speed)
        if roclimb == None:
            roclimb = 0
        aprsmsg = id+">OGADSB,qAS,"+config.ADSBname+":/" + \
            hora+'h'+lat+"\\"+lon+"^"+ccc+"/"+sss+"/"
        if altitude != None and altitude > 0:
            aprsmsg += "A=%06d" % int(altitude)
        aprsmsg += " id"+uniqueid+" %+04dfpm " % (int(roclimb))+" "+str(rot)+"rot fn"+flight+" "
        regmodel = getadsbreg(id[3:9])
        if regmodel:
            reg =regmodel['Reg']
            model=regmodel['Model']
            aprsmsg += "reg"+reg+" model"+model+" \n"
        else:
            aprsmsg += " \n"
        print("APRSMSG: ", aprsmsg)
        rtn = config.SOCK_FILE.write(aprsmsg)
        config.SOCK_FILE.flush()
        if rtn == 0:
            print("Error writing msg:", aprsmsg)

    return (True)

#-------------------------------------------------------------------------------------------------------------------#
#LEMD>OGNSDR,TCPIP*,qAC,GLIDERN2:/141436h4030.49NI00338.59W&/A=002280
#LEMD>OGNSDR,TCPIP*,qAC,GLIDERN2:>141436h v0.2.8.RPI-GPU CPU:0.6 RAM:710.8/972.2MB NTP:0.3ms/-5.5ppm +56.9C 2/2Acfts[1h] RF:+50-3.2ppm/+0.76dB/+47.4dB@10km[3859]


RPI = is_raspberrypi()


def adsbsetrec(sock, prt=False, store=False, aprspush=False):			# define on APRS the dummy OGN station
    t = datetime.utcnow()       		# get the date
    tme = t.strftime("%H%M%S")
    aprsmsg=config.ADSBname+">OGNSDR,TCPIP*:/"+tme+"h"+config.ADSBloc+" \n"
    print("APRSMSG: ", aprsmsg)
    rtn = sock.write(aprsmsg)
    sock.flush()
    if rtn == 0:
        print("Error writing msg:", aprsmsg)
    if RPI:
        from gpiozero import CPUTemperature
        tcpu = CPUTemperature()
        tempcpu= tcpu.temperature
    else:
        tempcpu = 0.0
    cpuload =psutil.cpu_percent()/100
    memavail=psutil.virtual_memory().available/(1024*1024)
    memtot =psutil.virtual_memory().total/(1024*1024)
    aprsmsg =config.ADSBname+">OGNSDR,TCPIP*:>"+tme+"h v0.3.0.ADSB CPU:"+str(cpuload)+" RAM:"+str(memavail)+"/"+str(memtot)+"MB NTP:0.4ms/-5.4ppm +"+str(tempcpu)+"C\n"
    print("APRSMSG: ", aprsmsg)
    rtn = sock.write(aprsmsg)
    sock.flush()

    return

# find all the fixes since TTIME . Scan all the adsb devices for new data


def adsbfindpos(ttime, conn, prt=False, store=False, aprspush=False):

    adsbpos = {"adsbpos": []}		# init the dict
    if OPENSKY:
        found = adsbopensky(adsbpos, ttime, prt=prt)
        now = datetime.utcnow()          # get the UTC time
        # number of seconds until beginning of the day 1-1-1970
        td = now-datetime(1970, 1, 1)
        adsbnow = int(td.total_seconds())  # Unix time - seconds from the epoch
    else:
        url = "http://"+config.ADSBhost+"/data.json"
        adsbfile = config.ADSBfile
        if not os.path.exists(adsbfile):
            now = datetime.utcnow()
            # number of second until beginning of the day of 1-1-1970
            return (ttime+1)		# return TTIME for next call

        pos = adsbgetapidata(adsbfile)   # get the JSON data from the ADSB server
        if prt:
            print(json.dumps(pos, indent=4))  # convert JSON to dictionary
        adsbnow = pos['now']		# timestamp from the ADSB data
        tracks = pos['aircraft']  # get the aircraft information
        # get all the devices with ADSB
        adsbaddpos(tracks, adsbpos, ttime, adsbnow, prt=prt)  # find the gliders since TTIME

    if prt:
        print(adsbpos)			# print the data
    if store:
        curs = conn.cursor()            # set the cursor for storing the fixes
        adsbstoreitindb(adsbpos, curs, conn)  # and store it on the DDBB
    if aprspush:
        adsbaprspush(adsbpos, conn, prt=prt)  # and push it into the OGN APRS
        # number of second until beginning of the day of 1-1-1970
    return (int(adsbnow))		# return TTIME for next call

#-------------------------------------------------------------------------------------------------------------------#
